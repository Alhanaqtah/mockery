// StructWithTag is an autogenerated mock type for the StructWithTag type
type StructWithTag struct {
	mock.Mock
}

// MethodA provides a mock function with given fields: v
func (_m *StructWithTag) MethodA(v *struct {
	FieldA int `json:"field_a"`
	FieldB int `json:"field_b" xml:"field_b"`
}) *struct {
	FieldC int `json:"field_c"`
	FieldD int `json:"field_d" xml:"field_d"`
} {
	ret := _m.Called(v)

	var r0 *struct {
		FieldC int `json:"field_c"`
		FieldD int `json:"field_d" xml:"field_d"`
	}
	if rf, ok := ret.Get(0).(func(*struct {
		FieldA int `json:"field_a"`
		FieldB int `json:"field_b" xml:"field_b"`
	}) *struct {
		FieldC int `json:"field_c"`
		FieldD int `json:"field_d" xml:"field_d"`
	}); ok {
		r0 = rf(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*struct {
				FieldC int `json:"field_c"`
				FieldD int `json:"field_d" xml:"field_d"`
			})
		}
	}

	return r0
}

type mockConstructorTestingTNewStructWithTag interface {
	mock.TestingT
	Cleanup(func())
}

// NewStructWithTag creates a new instance of StructWithTag. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewStructWithTag(t mockConstructorTestingTNewStructWithTag) *StructWithTag {
	mock := &StructWithTag{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
